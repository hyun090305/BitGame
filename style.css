  body {
  height: 100vh;
  margin: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;   /* 기존 space-between 제거 */
  align-items: center;
  font-family: sans-serif;
  background-color: #f0f0f0;
  text-align: center;
}

  #controls, #blockPanel {
    margin: 15px;
  }


  #blockPanel {
  width: 100px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

#gameScreen {
  display: flex;
  flex-direction: column;
  height: 100vh;              /* 전체 높이 */
  margin: 0;                  /* 혹시 기본 마진 있으면 제거 */
}

#gameLayout {
  flex: 1;                    /* 상단 h1과 하단 메뉴바 사이를 쭉 채움 */
  display: flex;
  justify-content: center;    /* 좌우 중앙 */
  align-items: center;        /* 상하 중앙 */
  gap: 2rem;
  margin: 0;                  /* inline style로 준 margin-top 제거 */
}
#mainScreen {
  padding: 50px;
}

.rightPanel {
  width: 200px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  flex-shrink: 0;
}

#mainScreen button {
  margin: 10px;
  padding: 12px 20px;
  font-size: 1.2rem;
}

#menuBar {
  width: 100%;
  background-color: #ddd;
  padding: 10px;
  text-align: center;
  position: fixed;
  bottom: 0;
  left: 0;
}

#menuBar button {
  margin: 0 5px;
  padding: 6px 10px;
}

  #grid {
  display: grid;
  gap: 2px;
  border: 2px solid black;
  grid-template-columns: repeat(var(--grid-cols, 6), 50px); /* 기존 */
  grid-template-rows: repeat(var(--grid-rows, 6), 50px);    /* 추가 */
}

#gridContainer {
  flex-shrink: 0;
  display: flex;
  justify-content: center;
  align-items: center;
}
.levelGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 1rem;
  width: 100%;
  max-width: 400px;
  margin: 1.5rem 0;
}

/* 이전: .levelBtn은 그냥 버튼이었음 */
/* 수정 후: */
.levelGrid .levelBtn {
  width: 100%;
  aspect-ratio: 1 / 1;          /* 정사각형 */
  position: relative;
  background: #e0e0ff;
  border: 1px solid #666;
  font-size: 1.2rem;
  cursor: pointer;
  display: flex;                /* 중앙 정렬용 추가 */
  justify-content: center;     /* 수평 중앙 */
  align-items: center;         /* 수직 중앙 */
}

.levelBtn {
  background-color: lavender;
  width: 120px;
  height: 160px;
  font-size: 1.2em;
  display: flex;                  /* 중요 */
  flex-direction: column;         /* 수직 방향 정렬 */
  justify-content: center;        /* 수직 가운데 정렬 */
  align-items: center;            /* 수평 가운데 정렬 */
  text-align: center;
  margin: 10px;
  border: 1px solid #aaa;
  cursor: pointer;
}

#wireStatusInfo,
#wireDeleteInfo,
#wireStatusMsg,
#wireDeleteMsg {
  display: block;
  margin: 6px 0;
  text-align: center;
}

  .cell {
    border: 1px solid #ccc;
    box-sizing: border-box;
    position: relative;
    background-color: white;
    width: 50px;
    height: 50px;
  }

  .cell.block {
    background-color: #e0e0ff;
    color: #003366;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .cell.wire {
    position: relative;
    background-color: #ffe;
  }

  /* ── 수직선 (│) 은 ::before 에만 그리기 ── */
  .cell.wire.wire-up::before,
  .cell.wire.wire-down::before {
    content: '';
    position: absolute;
    left: 50%;
    background-color: black;
    transform: translateX(-50%);
  }
  .cell.wire.wire-up::before {
    top: 0;
    height: 50%;
  }
  .cell.wire.wire-down::before {
    bottom: 0;
    height: 50%;
  }

  /* ── 수평선 (─) 은 ::after 에만 그리기 ── */
  .cell.wire.wire-left::after,
  .cell.wire.wire-right::after {
    content: '';
    position: absolute;
    top: 50%;
    background-color: black;
    transform: translateY(-50%);
  }
  .cell.wire.wire-left::after {
    left: 0;
    width: 50%;
  }
  .cell.wire.wire-right::after {
    right: 0;
    width: 50%;
  }

  /* ── 두 방향이 동시에 있을 땐 전체 길이로 ── */
  /* 세로 전체 (│) */
  .cell.wire.wire-up.wire-down::before {
    top: 0;
    height: 100%;
  }
  /* 가로 전체 (─) */
  .cell.wire.wire-left.wire-right::after {
    left: 0;
    width: 100%;
  }

  /* ── 배선 미리보기 강조 ── */
  .cell.wire-preview {
    background: #ffeca0;
  }

  /* ── 블록 아이콘 스타일 ── */
  .blockIcon {
    width: 60px;
    height: 30px;
    background-color: #e0e0ff;
    border: 1px solid #666;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    cursor: grab;
  }

  /* ── 휴지통 ── */
  #trash {
    width: 200px;
    height: 50px;
    margin: 20px auto;
    border: 2px dashed red;
    color: red;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* ── 4가지 코너 모양(ㄱ, ┐, └, ┘) 강제 반쪽 길이 ── */
  /* 세로선(│) – width만 4 ➜ 2 로 */
/* 세로선(│) – 굵기만 2 px */
.cell.wire.wire-up::before,
.cell.wire.wire-down::before{
  width:2px;
  /* ▽ 세로 점선 + 애니메이션 */
  background-image:repeating-linear-gradient(
        0deg,#000 0 26px,transparent 26px var(--unit));
  background-size:100% var(--unit);
  animation:dash-down 1s linear infinite;
}

/* 가로선(─) – 굵기를 height 로만 통일 */
.cell.wire.wire-left::after,
.cell.wire.wire-right::after{
  height:2px;
  /* ▽ 가로 점선 + 애니메이션 */
  background-image:repeating-linear-gradient(
        90deg,#000 0 26px,transparent 26px var(--unit));
  background-size:var(--unit) 100%;
  animation:dash-right 1s linear infinite;
}
  /* ① 수평 흐름용 --------------------------------------------------- */

  /* 셀 크기 변수(선택) */
:root{
  --unit:52px;          /* 셀 한 칸 간격 */
  /* 아래 네 값만 바꿔가며 테스트하세요 */
  --phase-right: 26px;   /* →  흐름 */
  --phase-left : 0px;  /* ←  흐름 (반 주기 만큼 밀어 예시) */
  --phase-down : 0px;   /* ↓  흐름 */
  --phase-up   : 26px;  /* ↑  흐름 */
  /* shape: down+right (┌) */
  --corner-offset-dr-right: 0px;
  --corner-offset-dr-down : 0px;

  /* shape: down+left  (┐) */
  --corner-offset-dl-left : 26px;
  --corner-offset-dl-down : 26px;

  /* shape: up+right   (└) */
  --corner-offset-ur-right: 26px;
  --corner-offset-ur-up   : 26px;

  /* shape: up+left    (┘) */
  --corner-offset-ul-left : 0px;
  --corner-offset-ul-up   : 0px;
  
  /* fallback */
  --corner-offset: 0px;
  --half-unit: calc(var(--unit) / 2);
}

/* ── 가로 기본선(h) ───────────────────────── */
.cell.wire.h:not(.corner)::after{
  content:'';
  position:absolute; left:0; top:50%; transform:translateY(-50%);
  width:100%; height:2px;

  /* 검정 26px → 투명 26px = 총 52px */
  background-image: repeating-linear-gradient(
        90deg, #000 0 26px, transparent 26px var(--unit));
  background-size: var(--unit) 100%;
  /* 열 번호(col)만큼 -52px씩 당겨 패턴 이어붙이기 */
  background-position:
      calc(-1 * var(--unit) * var(--col) + var(--phase-right)) 0;
}

/* ── 세로 기본선(v) ───────────────────────── */
.cell.wire.v:not(.corner)::before{
  content:'';
  position:absolute; top:0; left:50%; transform:translateX(-50%);
  width:2px; height:100%;

  background-image: repeating-linear-gradient(
        0deg, #000 0 26px, transparent 26px var(--unit));
  background-size: 100% var(--unit);
  /* 행 번호(row)만큼 -52px씩 당겨 패턴 이어붙이기 */
  background-position:
      0 calc(-1 * var(--unit) * var(--row) + var(--phase-down));
}




@keyframes dash-right {
  from { background-position: calc(-1 * var(--unit) * var(--col) + var(--phase-right)) 0; }
  to   { background-position: calc(-1 * var(--unit) * var(--col) + var(--phase-right) + var(--unit)) 0; }
}
@keyframes dash-left {
  from { background-position: calc(-1 * var(--unit) * var(--col) + var(--phase-left)) 0; }
  to   { background-position: calc(-1 * var(--unit) * var(--col) + var(--phase-left) - var(--unit)) 0; }
}
@keyframes dash-down {
  from { background-position: 0 calc(-1 * var(--unit) * var(--row) + var(--phase-down)); }
  to   { background-position: 0 calc(-1 * var(--unit) * var(--row) + var(--phase-down) + var(--unit)); }
}
@keyframes dash-up {
  from { background-position: 0 calc(-1 * var(--unit) * var(--row) + var(--phase-up)); }
  to   { background-position: 0 calc(-1 * var(--unit) * var(--row) + var(--phase-up) - var(--unit)); }
}





/* 1) 애니메이션이 적용될 직선 셀은 배경색을 투명으로 */
.cell.wire.h::after,
.cell.wire.v::before {
  background-color: transparent;   /* ≤ 점선 배경만 보이게 */
}

/* 2) 흐름 방향(flow-*)이 붙은 셀도 동일 */
/* 코너엔 투명 처리하지 않는다 */
.cell.wire.flow-right:not(.corner)::after,
.cell.wire.flow-left:not(.corner)::after,
.cell.wire.flow-down:not(.corner)::before,
.cell.wire.flow-up:not(.corner)::before{
  background-color: transparent;
}


.cell.wire.h::after,
.cell.wire.v::before{
  background-color: transparent;
}

.cell.wire.wire-up::before,
.cell.wire.wire-down::before,
.cell.wire.wire-left::after,
.cell.wire.wire-right::after{
  background-color: transparent;
}

/* → 흐름 */
.cell.wire.flow-right::after{
  /* 기존 */  animation:dash-right 1s linear infinite;
  /* 위상 */  background-position:
      calc(-1 * var(--unit) * var(--col) + var(--phase-right)) 0;
}

/* ← 흐름 */
.cell.wire.flow-left::after{
  animation:dash-left 1s linear infinite;
  background-position:
      calc(-1 * var(--unit) * var(--col) + var(--phase-left)) 0;
}

/* ↓ 흐름 */
.cell.wire.flow-down::before{
  animation:dash-down 1s linear infinite;
  background-position:
      0 calc(-1 * var(--unit) * var(--row) + var(--phase-down));
}

/* ↑ 흐름 */
.cell.wire.flow-up::before{
  animation:dash-up 1s linear infinite;
  background-position:
      0 calc(-1 * var(--unit) * var(--row) + var(--phase-up));
}

.cell.wire.wire-up::before {
  background-position:
      0 calc(-1 * var(--unit) * var(--row) + var(--phase-up));
}
.cell.wire.wire-down::before {
  background-position:
      0 calc(-1 * var(--unit) * var(--row) + var(--phase-down));
}

.cell.wire.wire-left::after {
  background-position:
      calc(-1 * var(--unit) * var(--col) + var(--phase-left)) 0;
}
.cell.wire.wire-right::after {
  background-position:
      calc(-1 * var(--unit) * var(--col) + var(--phase-right)) 0;
}

/* ── 드래그된 state 에 따라 corner-offset 덮어쓰기 ── */
/* shape down+right (┌) + flow-right */
.cell.wire.corner.wire-down.wire-right.flow-right {
  --corner-offset: var(--corner-offset-dr-right);
}
/* shape down+right (┌) + flow-down */
.cell.wire.corner.wire-down.wire-right.flow-down {
  --corner-offset: var(--corner-offset-dr-down);
}

/* shape down+left (┐) + flow-left */
.cell.wire.corner.wire-down.wire-left.flow-left {
  --corner-offset: var(--corner-offset-dl-left);
}
/* shape down+left (┐) + flow-down */
.cell.wire.corner.wire-down.wire-left.flow-down {
  --corner-offset: var(--corner-offset-dl-down);
}

/* shape up+right (└) + flow-right */
.cell.wire.corner.wire-up.wire-right.flow-right {
  --corner-offset: var(--corner-offset-ur-right);
}
/* shape up+right (└) + flow-up */
.cell.wire.corner.wire-up.wire-right.flow-up {
  --corner-offset: var(--corner-offset-ur-up);
}

/* shape up+left (┘) + flow-left */
.cell.wire.corner.wire-up.wire-left.flow-left {
  --corner-offset: var(--corner-offset-ul-left);
}
/* shape up+left (┘) + flow-up */
.cell.wire.corner.wire-up.wire-left.flow-up {
  --corner-offset: var(--corner-offset-ul-up);
}

/* ── 코너 셀 전용 keyframes ── */
@keyframes dash-right-corner {
  from { background-position:
      calc(-1 * var(--unit) * var(--col)
           + var(--phase-right) - var(--corner-offset))
      0; }
  to   { background-position:
      calc(-1 * var(--unit) * var(--col)
           + var(--phase-right) - var(--corner-offset)
           + var(--unit))
      0; }
}
@keyframes dash-left-corner {
  from { background-position:
      calc(-1 * var(--unit) * var(--col)
           + var(--phase-left) - var(--corner-offset))
      0; }
  to   { background-position:
      calc(-1 * var(--unit) * var(--col)
           + var(--phase-left) - var(--corner-offset)
           - var(--unit))
      0; }
}
@keyframes dash-down-corner {
  from { background-position:
      0 calc(-1 * var(--unit) * var(--row)
             + var(--phase-down) - var(--corner-offset)); }
  to   { background-position:
      0 calc(-1 * var(--unit) * var(--row)
             + var(--phase-down) - var(--corner-offset)
             + var(--unit)); }
}
@keyframes dash-up-corner {
  from { background-position:
      0 calc(-1 * var(--unit) * var(--row)
             + var(--phase-up) - var(--corner-offset)); }
  to   { background-position:
      0 calc(-1 * var(--unit) * var(--row)
             + var(--phase-up) - var(--corner-offset)
             - var(--unit)); }
}

/* ── override: corner 에 새 keyframes 와 함께 animation 재정의 ── */

/* ── 코너 셀 전용 override (흐름+모양 모두 체크) ── */
/* → 흐름이면서 오른쪽 분기 코너 */
.cell.wire.flow-right.corner.wire-right::after {
  animation: dash-right-corner 1s linear infinite;
  background-position:
    calc(-1 * var(--unit) * var(--col)
         + var(--phase-right) - var(--corner-offset))
    0;
}

/* ← 흐름이면서 왼쪽 분기 코너 */
.cell.wire.flow-left.corner.wire-left::after {
  animation: dash-left-corner 1s linear infinite;
  background-position:
    calc(-1 * var(--unit) * var(--col)
         + var(--phase-left) - var(--corner-offset))
    0;
}

/* ↓ 흐름이면서 아래 분기 코너 */
.cell.wire.flow-down.corner.wire-down::before {
  animation: dash-down-corner 1s linear infinite;
  background-position:
    0 calc(-1 * var(--unit) * var(--row)
           + var(--phase-down) - var(--corner-offset));
}

/* ↑ 흐름이면서 위 분기 코너 */
.cell.wire.flow-up.corner.wire-up::before {
  animation: dash-up-corner 1s linear infinite;
  background-position:
    0 calc(-1 * var(--unit) * var(--row)
           + var(--phase-up) - var(--corner-offset));
}

#simulateButton {
  margin: 10px;
  padding: 8px 12px;
  border: none;
  border-radius: 4px;
  background-color: #4CAF50;
  color: white;
  font-size: 1rem;
  cursor: pointer;
}
#simulateButton:hover {
  background-color: #45a049;
}

/* INPUT 블록 클릭 시 포인터 표시 */
.cell.block[data-type="INPUT"] {
  cursor: pointer;
}

/* OUTPUT 블록 강조 (결과 표시) */
.cell.block[data-type="OUTPUT"] {
  font-weight: bold;
}

/* 활성(1) 상태 표시 (색각 이상 고려해 테두리 점선) */
.cell.block.active {
  outline: 2px dashed currentColor;
  outline-offset: -2px;
}

#gradingTable {
  width: 100%;
  border-collapse: collapse;
  margin-top: 1rem;
}

#gradingTable th,
#gradingTable td {
  border: 1px solid #ccc;
  padding: 8px 12px;
  text-align: center;
}

#gradingTable th {
  background-color: #f9f9f9;
}

#gradingTable tr.correct td {
  background-color: #eaffea;
}

#gradingTable tr.wrong td {
  background-color: #ffeaea;
}

#gradingArea {
  width: 100%;
  max-width: 600px;
  background: #ffffff;
  border-top: 2px solid #ccc;
  margin-top: 20px;
  padding: 1.5rem;
  font-family: 'Noto Sans KR', sans-serif;
  font-size: 1rem;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  border-radius: 12px;
  text-align: left;
}

.gradeRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  border-bottom: 1px solid #eee;
}

.gradeRow.correct::after {
  content: "✔️ 정답";
  color: green;
  font-weight: bold;
}
.gradeRow.wrong::after {
  content: "❌ 오답";
  color: red;
  font-weight: bold;
}

#gradeResultSummary {
  margin-top: 1rem;
  font-size: 1.2rem;
  font-weight: bold;
  text-align: center;
  color: #333;
}
#returnToEditBtn {
  margin-top: 1.5rem;
  padding: 10px 16px;
  background: #555;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}
#returnToEditBtn:hover {
  background: #333;
}
.levelBtn.cleared {
  background-color: #4caf50;
  color: white;
  font-weight: bold;
}
#guestbookArea {
  margin-top: 2rem;
  padding: 1rem;
  background: #fffbe6;
  border: 1px solid #ccc;
  border-radius: 10px;
  max-width: 600px;
}

#guestbookArea textarea,
#guestbookArea input {
  width: 100%;
  margin: 4px 0;
  padding: 8px;
  box-sizing: border-box;
}

.modal {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: white;
  display: flex; justify-content: center; align-items: center;
  z-index: 999;
}
.modal-content {
  background: white;
  padding: 2rem;
  border-radius: 10px;
  text-align: center;
}

#chapterGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 1.5rem;
  margin: 2rem 0;
}

.chapterCard {
  background: white;
  padding: 1.5rem;
  border-radius: 12px;
  box-shadow: 0 3px 10px rgba(0,0,0,0.1);
  text-align: center;
  transition: transform 0.2s ease;
  cursor: pointer;
}

.chapterCard:hover {
  transform: scale(1.03);
  background-color: #f9f9ff;
}

.chapterCard h3 {
  margin-bottom: 0.5rem;
}

.chapterCard p {
  font-size: 0.9rem;
  color: #333;
}

.cell.block[data-type="JUNCTION"] {
  background-color: #ddd;
  font-weight: bold;
  color: #333;
}

.cell[data-type="JUNCTION"].error {
  border: 2px solid red;
  box-shadow: 0 0 6px red;
}